



number id: 29
label id: Study_30:0
puzzle content:
def sat(li: List[int]):
    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])
False->Fail




number id: 48
label id: BooleanPythagoreanTriples:0
puzzle content:
def sat(colors: List[int], n=100):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
False->Fail




number id: 61
label id: No3Colinear:2
puzzle content:
def sat(coords: List[List[int]], side=1, num_points=1):
    for i1 in range(len(coords)):
        x1, y1 = coords[i1]
        assert 0 <= x1 < side and 0 <= y1 < side
        for i2 in range(i1):
            x2, y2 = coords[i2]
            for i3 in range(i2):
                x3, y3 = coords[i3]
                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0
    return len({(a, b) for a, b in coords}) == len(coords) >= num_points
run error 3+




number id: 81
label id: CardGame24:0
puzzle content:
def sat(expr: str, nums=[3, 7, 3, 7]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
run error 3+




number id: 84
label id: CardGame24:3
puzzle content:
def sat(expr: str, nums=[8, 3, 12, 1]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
run error 3+




number id: 108
label id: SeparateParenGroups:0
puzzle content:
def sat(ls: List[str], combined="() (()) ((() () ())) (() )"):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
True->Success




number id: 110
label id: SeparateParenGroups:2
puzzle content:
def sat(ls: List[str], combined=" ((((() ())( ( ))())))   "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
run error 3+




number id: 114
label id: Frac:1
puzzle content:
def sat(x: float, v=93.86070917102649):
    return 0 <= x < 1 and (v - x).is_integer()
True->Success




number id: 115
label id: Frac:2
puzzle content:
def sat(x: float, v=-6.770237138115334):
    return 0 <= x < 1 and (v - x).is_integer()
False->Fail




number id: 188
label id: ParseMusic:0
puzzle content:
def sat(beats: List[int], score="o o o| o| .| .| .| o| o| o o o| .|"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
run error 3+




number id: 192
label id: ParseMusic:4
puzzle content:
def sat(beats: List[int], score=""):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
run error 3+




number id: 195
label id: OverlappingCount:2
puzzle content:
def sat(ans: List[int], s="sutapifitextidavyjedakotextopogonudy", sub="te", count=2):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
False->Fail




number id: 212
label id: Rescale:4
puzzle content:
def sat(ans: List[float], nums=[23.976551109194304, 1.4655002766247416]):
    assert min(ans) == 0.0 and max(ans) == 1.0
    a = min(nums)
    b = max(nums)
    for i in range(len(nums)):
        x = a + (b - a) * ans[i]
        assert abs(nums[i] - x) < 1e-6
    return True
True->Success




number id: 226
label id: LargestDivisor:3
puzzle content:
def sat(d: int, n=15466):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
True->Success




number id: 257
label id: FindPositives:4
puzzle content:
def sat(positives: List[int], nums=[]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
False->Fail




number id: 277
label id: UniqueSorted:4
puzzle content:
def sat(li: List[int], orig=[1, -5, 6, 2, -7, -6, 5, -5, 3, 7, 4, -10, -2, 3, 7, 9, -3, 8, 7]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
run error 3+




number id: 283
label id: SevenElevenThirteen:0
puzzle content:
def sat(li: List[List[int]], n=19723, lower=1000):
    assert len({(i, j) for i, j in li}) >= lower, "not enough 7's (ignoring duplicates)"
    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)
run error 3+




number id: 285
label id: SevenElevenThirteen:2
puzzle content:
def sat(li: List[List[int]], n=8, lower=0):
    assert len({(i, j) for i, j in li}) >= lower, "not enough 7's (ignoring duplicates)"
    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)
run error 3+




number id: 295
label id: ThreeCycle:3
puzzle content:
def sat(s: str, target="quitextaf"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
False->Fail




number id: 320
label id: PairZeroSum:3
puzzle content:
def sat(inds: List[int], nums=[61, 13, 32, -67, -29, 6, 65, 82, -36, -90, -3, -53, -80, 52, -20, 14, -58, 1, 14, 88, 90, -76, -83, 47, -20, -26, 5, 71, 29, -51, -6, 38, -42, -48, 9, -74, -37, -86, -31, -63, -45, -74, -40, 23, -16, 24, -6, -93, -46, -42, -4, -85, -91, 71, -72, 11, -33, 33, -82, -67, -34, -60, 89, 60, 26, -12, -92, 42, -92, -58, -37, 9, -38, 54, 34, 25, 85, -65, -79, 33, -52, -72, -80, -76, -39, 24, -2, 40, -53, -14, 8, 21, 7, 46, -88, -67]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
False->Fail




number id: 339
label id: Median:2
puzzle content:
def sat(x: int, nums=[], upper=0):
    dev = sum(n - x for n in nums)
    return dev <= upper
run error 3+




number id: 341
label id: Median:4
puzzle content:
def sat(x: int, nums=[-2410166269, 5887293672], upper=-8297459941):
    dev = sum(n - x for n in nums)
    return dev <= upper
False->Fail




number id: 343
label id: Palindrome:1
puzzle content:
def sat(pals: List[bool], strs=['getuteg', 'quiuq', 'tebetextxetebet', 'quyquykame', 'palimubibibumilap', 'chirowykigollogikyworihc', 'jyt', 'zenoryluchydoquuzohehozuuqodyhculyronez', 'gumizilixogylygoxilizimug']):
    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))
True->Success




number id: 359
label id: BelowThreshold:1
puzzle content:
def sat(indexes: List[int], nums=[35, -96, -51, 7, 56, 0], thresh=-30):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
run error 3+




number id: 393
label id: LargestPrimeFactor:0
puzzle content:
def sat(p: int, n=101076):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
False->Fail




number id: 416
label id: Fib3:3
puzzle content:
def sat(init: List[int], target=4644):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
run error 3+




number id: 434
label id: MissingBananas:1
puzzle content:
def sat(bananas: int, bowl="7 apples and 9 oranges", total=21):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
True->Success




number id: 449
label id: WildSort:1
puzzle content:
def sat(strange: List[int], li=[8, 1, 0, 8, 1, 5, 2, 1, 7, 3, 0, 4, 0, 3, 8, 0, 9, 0, 7]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
run error 3+




number id: 452
label id: WildSort:4
puzzle content:
def sat(strange: List[int], li=[7, 1, 3]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
False->Fail




number id: 457
label id: HeronTriangle:4
puzzle content:
def sat(coords: List[List[float]], sides=[45.986905476840235, 79.97976343909342, 86.26149779271437]):
    assert len(coords) == 3
    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]
    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))
False->Fail




number id: 462
label id: InvestigateCrash:4
puzzle content:
def sat(problem: int, weights=[43, 37, 79, 37, 20], max_weight=222):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
True->Success




number id: 495
label id: NearbyDuplicates:1
puzzle content:
def sat(indices: List[int], s="aeEm%%uIV0imR&xUvQvZf#1z4"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
False->Fail




number id: 500
label id: Grader:1
puzzle content:
def sat(grades: List[str], gpas=[3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
run error 3+




number id: 519
label id: EvenOddSum:4
puzzle content:
def sat(even_odd_sum: int, nums=[48, -42, -19, -82, -71, -57, -85, 61, 61, -86]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
False->Fail




number id: 533
label id: SubstitutionCypher:2
puzzle content:
def sat(encrypted: str, orig="byfykovevuvyxanofi lygolono pyzuh t"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
run error 3+




number id: 546
label id: IdentifyZeroTrips:0
puzzle content:
def sat(zero_sums: List[bool], trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):
    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))
run error 3+




number id: 554
label id: WeirdDecodeVowels:3
puzzle content:
def sat(s: str, target="That last test was a bad test!"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
False->Fail




number id: 555
label id: WeirdDecodeVowels:4
puzzle content:
def sat(s: str, target="pneumonoultramicroscopicsilicovolanoconiosis"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
False->Fail




number id: 556
label id: LargestPrimeDigitSum:0
puzzle content:
def sat(ans: List[int], nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
False->Fail




number id: 576
label id: UppercaseEven:0
puzzle content:
def sat(positions: List[int], s="ThIs is A tEsT, Or *IS* iT?"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
run error 3+




number id: 582
label id: ClosestInteger:1
puzzle content:
def sat(n: int, x=3557710970.9527555):
    return abs(n - x) <= 0.5
run error 3+




number id: 606
label id: SortedOdds:0
puzzle content:
def sat(sub: List[int], nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
run error 3+




number id: 637
label id: ParityExchange:1
puzzle content:
def sat(swaps: List[List[int]], nums1=[-4, -8, -10, -6, 0, -3, -7, 5], nums2=[-6, 6, -8, -7, -7]):
    copy1 = nums1[:]
    copy2 = nums2[:]
    for i, j in swaps:
        copy1[i], copy2[j] = copy2[j], copy1[i]
    return all(n % 2 == 0 for n in copy1)
True->Success




number id: 641
label id: CharCounts:0
puzzle content:
def sat(s: str, counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
run error 3+




number id: 653
label id: ReplaceMe:2
puzzle content:
def sat(answers: List[str], lst=[]):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
False->Fail




number id: 675
label id: ConsonantFilter:4
puzzle content:
def sat(words: List[str], s="thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep", n=2):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
False->Fail




number id: 723
label id: PrimeIntervalIntersection:2
puzzle content:
def sat(interval2: List[int], interval1=[0, 2381571]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
True->Success




number id: 752
label id: CeilingSquares:1
puzzle content:
def sat(running_squares: List[int], x=[9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
True->Success




number id: 759
label id: LastLetters:3
puzzle content:
def sat(y: List[bool], x=['ryxadec', 'pyfixotibujadyxe', 'mopubywewexi witethig 7', ' !', 'jethi sed c', 'lotextusavufubynyb', 'wuxesafetatextysima pebutextiwafufok', 'tuchonip', ' S', 'xyvovikofutex pylekazuquekedajota E', 'wik xofoxujegerigubo ?', 'gipimakude 1', ' O', ' ^', 'lakiquuvuhenugu vajyquy P', ' 6', 'fezore', 'vabithin textusichytilejocoke', ' B', 'lasuthasebuvy que &', 'mymanuzuzudyc thazufys y', '', ' ?', 'gecohywelawu', 'wath']):
    assert len(x) == len(y)
    for s, b in zip(x, y):
        if len(s.split(" ")[-1]) == 1:
            assert b == s[-1].isalpha()
        else:
            assert not b
    return True
run error 3+




number id: 811
label id: SortByDigitSum:4
puzzle content:
def sat(ordered: List[int], nums=[232, -710]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
True->Success




number id: 820
label id: Threeples:3
puzzle content:
def sat(trips: List[List[int]], a=[6, 3, 5, -1, 8, 8], count=4):
    assert len({tuple(t) for t in trips}) >= count
    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)
False->Fail




number id: 822
label id: PlanetRange:0
puzzle content:
def sat(planets_between: List[str], a="Mars", b="Neptune"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
True->Success




number id: 827
label id: EvenWords:0
puzzle content:
def sat(evens: List[str], words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
run error 3+




number id: 828
label id: EvenWords:1
puzzle content:
def sat(evens: List[str], words=['valafytextulu', 'quyjylixyvy', 'mavusegojysaquo']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
run error 3+




number id: 853
label id: RotateString:1
puzzle content:
def sat(r: str, s="fuz tox banu dukukyjosuthihono", t="sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt"):
    return r in t and len(r) == len(s) and r in s + s
False->Fail




number id: 876
label id: MostUnique:4
puzzle content:
def sat(s: str, pool=['th', 's', 'bulonu', 'r']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
True->Success




number id: 881
label id: HungryRabbits:4
puzzle content:
def sat(results: List[List[int]], stats=[[1, 1, 9]]):
    assert len(results) == len(stats)
    for (tot, remaining), (eaten, need, stock) in zip(results, stats):
        assert tot - eaten == min(need, stock)
        assert stock < need and remaining == 0 or stock >= need and remaining + need == stock
    return True
run error 3+




number id: 897
label id: EvenBetween:4
puzzle content:
def sat(ab: List[int], s="6062860630606326063460636"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
False->Fail




number id: 920
label id: DecreasingCountComparison:2
puzzle content:
def sat(n: int, scores=[44, 42, 41, 41, 40, 40, 39, 38, 38, 38, 37, 33, 32, 31, 31, 31, 30, 29, 28, 26, 25, 24, 24, 23, 23, 22, 20, 20, 20, 18, 17, 17, 16, 16, 12, 9, 9, 7, 6, 5, 4, 2], k=1):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
False->Fail




number id: 929
label id: DominoTile:1
puzzle content:
def sat(squares: List[List[int]], m=30, n=12, target=360):
    covered = []
    for i1, j1, i2, j2 in squares:
        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)
        covered += [(i1, j1), (i2, j2)]
    return len(set(covered)) == len(covered) == target
run error 3+




number id: 937
label id: IncDec:4
puzzle content:
def sat(n: int, ops=['x--', 'x++', '++x', '--x', 'x++', '--x', 'x--'], target=61813):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
True->Success




number id: 951
label id: SortPlusPlus:4
puzzle content:
def sat(s: str, inp="2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
run error 3+




number id: 1021
label id: Factor47:4
puzzle content:
def sat(d: int, n=323190690645573746957862):
    return n % d == 0 and all(i in "47" for i in str(d))
False->Fail




number id: 1022
label id: Count47:0
puzzle content:
def sat(d: int, n=123456789):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
True->Success




number id: 1037
label id: Dada:0
puzzle content:
def sat(s: str, a=5129, d=17):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
False->Fail




number id: 1069
label id: FivePowers:3
puzzle content:
def sat(s: str, n=2):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
True->Success




number id: 1071
label id: CombinationLock:0
puzzle content:
def sat(states: List[str], start="424", combo="778", target_len=12):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
run error 3+




number id: 1110
label id: MaxConsecutiveProduct:4
puzzle content:
def sat(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
True->Success




number id: 1123
label id: BillSums:2
puzzle content:
def sat(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
False->Fail




number id: 1128
label id: BoxVolume:2
puzzle content:
def sat(sides: List[int], options=[5, 5684341886080801486968994140625, 1694065894508600678136645001359283924102783203125], n=14164235936814247246943953676783316651469999599259488526297703814252125093918086614885937400554283434172053854937092875501351523725603695985262279092166781262962870903549601084831041808313096168206454204432965872990952135614781500037949647186895146848775449563088704805081355726771444219003252553140494372583795600460039446480996347267095412342936844101488043829191704193224433757153659988332565127014442298522610686943372161710084163946718544591837540089627956441911856011461878779300604946911334991455078125, max_dim=18):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
False->Fail




number id: 1130
label id: BoxVolume:4
puzzle content:
def sat(sides: List[int], options=[2, 8, 64, 256], n=3885337784451458141838923813647037813284813678104279042503624819477808570410416996352, max_dim=36):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
False->Fail




number id: 1145
label id: CubicRoot:4
puzzle content:
def sat(x: float, coeffs=[-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
run error 3+




number id: 1169
label id: GeometricSequence:3
puzzle content:
def sat(x: List[int], a=-777, r=4, l=103):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
run error 3+




number id: 1201
label id: ListDistinctSum:0
puzzle content:
def sat(x: List[int], n=4, s=2021):
    return len(x) == n and sum(x) == s and len(set(x)) == n
False->Fail




number id: 1227
label id: ZipStr:1
puzzle content:
def sat(s: str, substrings=['quifelota', 'chyhimyvemene', 'ge']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
run error 3+




number id: 1233
label id: ReverseCat:2
puzzle content:
def sat(s: str, substrings=['ripihuquyrenytu', 'quosafyji', 'chyguzocuzuqu', 'futhixequyb']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
False->Fail




number id: 1234
label id: ReverseCat:3
puzzle content:
def sat(s: str, substrings=['thacovatukoliva', 'maquyfezisothizyp', 'ka', 'benegiquememif']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
False->Fail




number id: 1235
label id: ReverseCat:4
puzzle content:
def sat(s: str, substrings=['t', 'vochemachylit', 'vutextynydakelopi', 'fazapydomozamochug']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
False->Fail




number id: 1240
label id: EngineerNumbers:4
puzzle content:
def sat(ls: List[str], n=59, a="hokitextawelaxah", b="maryhedu"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
False->Fail




number id: 1255
label id: CenteredString:4
puzzle content:
def sat(s: str, target="tenuhije", length=6):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
True->Success




number id: 1265
label id: CompleteParens:4
puzzle content:
def sat(t: str, s="))())l"):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
run error 3+




number id: 1301
label id: Oscillators:1
puzzle content:
def sat(init: List[List[int]], period=1):
    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells

    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)
    live = target
    for t in range(period):
        visible = {z + d for z in live for d in deltas}
        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}
        if live == target:
            return t + 1 == period
False->Fail




number id: 1316
label id: Nim:3
puzzle content:
def sat(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]):

    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap
        vals = sorted(state, reverse=True)
        i_largest = state.index(vals[0])  # largest heap
        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie

    state = initial_state[:]  # copy
    for i, n in moves:
        assert 0 < n <= state[i], "Illegal move"
        state[i] -= n
        if set(state) == {0}:
            return True  # you won!
        assert any(state), "You lost!"
        bot_move()
False->Fail




number id: 1350
label id: ShortestPath:0
puzzle content:
def sat(path: List[int], weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
run error 3+




number id: 1358
label id: UnweightedShortestPath:3
puzzle content:
def sat(path: List[int], edges=[[6, 0], [6, 2], [6, 5], [6, 4], [1, 4], [4, 3], [5, 3], [4, 4], [3, 1], [4, 6], [4, 2], [0, 2], [6, 6], [2, 3], [1, 0], [1, 5], [0, 0], [5, 4], [0, 1], [1, 2], [0, 4], [2, 5], [3, 0]], u=4, v=2, bound=2):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
True->Success




number id: 1373
label id: OddPath:3
puzzle content:
def sat(p: List[int], edges=[[6, 6], [3, 6], [5, 0], [7, 16], [9, 12], [10, 3], [3, 5], [14, 17], [10, 14], [15, 3], [17, 15], [8, 18], [1, 12], [3, 7], [12, 17], [15, 15], [6, 2], [10, 9], [5, 13], [2, 15], [8, 5], [9, 15], [10, 6], [10, 17], [3, 9], [2, 6], [4, 1], [7, 12], [13, 1], [15, 17], [13, 5], [14, 10], [0, 17], [0, 11], [4, 17], [1, 11], [12, 18]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
False->Fail




number id: 1420
label id: PickNearNeighbors:1
puzzle content:
def sat(keep: List[bool], heights=[6, 12, 26, 4, 25, 20, 15, 14, 18, 22, 19, 23, 27, 13, 9, 28, 17, 11, 29, 7, 1, 10, 2, 0, 21, 3, 5, 8, 16, 24]):
    n = int(len(heights) ** 0.5)
    assert sorted(heights) == list(range(n * n + n)), "hint: heights is a permutation of range(n * n + n)"
    kept = [i for i, k in zip(heights, keep) if k]
    assert len(kept) == 2 * n, "must keep 2n items"
    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices
    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))
run error 3+




number id: 1440
label id: LearnParityWithNoise:1
puzzle content:
def sat(inds: List[int], vecs=[3026078031409368634, 7146400157417466997, 5230715399550451735, 5711439032267145442, 7548327835869100414, 6708827919346401215, 3738394021903457634, 8572217357536520619, 2068990701252216912, 2527297846676040375, 8268732787978254795, 61203570143025212, 7342810871883169101, 5130109338028331308, 7559050022362805022, 4688300453824606274, 6132540541907873970, 4336830827866175311, 4658177358737495247, 5084071062462878715, 189501720066641238, 8940114256708424722, 5113924146720829221, 4787179834139114336, 4911869756119486218, 8254870450128749041, 4438177035195637074, 5842829643884011320, 4053162460261950208, 2418313591679938260, 3183962173259338720, 5424349679395645015, 8721363683850881601, 4309489519137374818, 4668810188571429750, 1619719991930582198, 7466888377266384808, 9012877516210312432, 5806707934012633661, 4901689063540216433, 5129789419720858519, 5461292526835029654, 8002292066627476387, 22896265023092245, 6377528370731564059, 8326396311104510171, 6275763356808207618, 5855722006919947060, 5284812396814908585, 4183862905187398029, 961125315693824082, 3066435959716339320, 4359457050975539676, 3745610113055211253, 5616892323431402644, 2423996313938618029, 3342319460472332063, 4574429521762476750, 530929890003939982, 6518361635319838485, 4705876417632921613, 8702130161668730198, 7903182592921575528, 141670616557704814, 6302770439830462635, 8261043567365748099, 438838480425402424, 5938030420618506624, 6388919631545923446, 6289510808724564483, 6268010263591290952, 14114260020922590, 7967256030154091406, 7834360030773781051, 7195168470041102120, 2144111587187695127, 4188284497153593189, 7490392562013822833, 2395367579472417027, 1234942756280497811, 149618691938860164, 7115847656533661705, 2829618956277039440, 2931490206384957203, 6476287337767581762, 945977554281930779, 8036974190540567032, 5620546732979542987, 7534852936547208732, 3612963124933737363, 3304259407192763500, 6531357621325258614, 2061695547096959296, 3891046108540743566, 3659303839675510400, 2840571068268977729, 6021300208671005128, 5523531622352728473, 3164481775218709281, 1433373373144701739, 5040760773694741353, 8699918547789986541, 9211723439219092053, 3601466436760036882, 7470213384180375061, 1117614654415514338, 6489709663619239074, 5606821764793080769, 5533040684385323261, 1663669870068057261, 117658820550690687, 5802967177524872313, 824677791803551085, 8130960541536503068, 7941328653734718836, 3551730520657107195, 3183297803310667173, 1744452363855034208, 2206249608643212372, 6805671707252313743, 3765414947444962371, 6871722428624542946, 5429903326499666841, 9118768768355899725, 2775018401536039120, 2838922854846376990, 3633686101842554817, 7756171914139767657, 1797750566355726798, 1145745704236160436, 7192058872525801155]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
run error 3+




number id: 1454
label id: GCD_multi:4
puzzle content:
def sat(n: int, nums=[8154539588421190, 128861795], lower_bound=64216730):
    return all(i % n == 0 for i in nums) and n >= lower_bound
False->Fail




number id: 1512
label id: BallotProblem:3
puzzle content:
def sat(counts: List[int], target_prob=0.5803571428571429):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
False->Fail




number id: 1529
label id: StrAdd:3
puzzle content:
def sat(st: str, a="dyr", b="dyr"):
    return st + a == b
True->Success




number id: 1533
label id: StrSetLen:2
puzzle content:
def sat(s: str, dups=1):
    return len(set(s)) == len(s) - dups
True->Success




number id: 1596
label id: StrSplitter:1
puzzle content:
def sat(x: str, parts=['kowot', 'quimimy'], string="kowottextihocavikirofegyfquimimy"):
    return string.split(x) == parts
True->Success




number id: 1597
label id: StrSplitter:2
puzzle content:
def sat(x: str, parts=['f', 'thixaresiquagipoquas', 'fytylu', 'jywaxaw'], string="fdetthixaresiquagipoquasdetfytyludetjywaxaw"):
    return string.split(x) == parts
True->Success




number id: 1607
label id: StrParts:2
puzzle content:
def sat(parts: List[str], sep="xusoquyvamathila", string="bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
True->Success




number id: 1627
label id: ListAt:2
puzzle content:
def sat(i: int, li=[99, 51, -28, -69, -90, -15, 7, -67], target=51):
    return li[i] == target
True->Success




number id: 1658
label id: IntNeg:3
puzzle content:
def sat(x: int, a=-6405550227918699):
    return -x == a
True->Success




number id: 1660
label id: IntSum:0
puzzle content:
def sat(x: int, a=1073258, b=72352549):
    return a + x == b
True->Success




number id: 1697
label id: IntNegSquareRoot:2
puzzle content:
def sat(n: int, a=1940392439040171204):
    return a == n * n and n < 0
run error 3+




number id: 1707
label id: FloatNegSquareRoot:2
puzzle content:
def sat(x: float, a=1363713245):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
False->Fail
success_Q: 27
error_Q: 35




number id: 29
label id: Study_30:0
puzzle content:
def sat(li: List[int]):
    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])
False->Fail




number id: 48
label id: BooleanPythagoreanTriples:0
puzzle content:
def sat(colors: List[int], n=100):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
False->Fail




number id: 61
label id: No3Colinear:2
puzzle content:
def sat(coords: List[List[int]], side=1, num_points=1):
    for i1 in range(len(coords)):
        x1, y1 = coords[i1]
        assert 0 <= x1 < side and 0 <= y1 < side
        for i2 in range(i1):
            x2, y2 = coords[i2]
            for i3 in range(i2):
                x3, y3 = coords[i3]
                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0
    return len({(a, b) for a, b in coords}) == len(coords) >= num_points
run error 3+




number id: 81
label id: CardGame24:0
puzzle content:
def sat(expr: str, nums=[3, 7, 3, 7]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
False->Fail




number id: 84
label id: CardGame24:3
puzzle content:
def sat(expr: str, nums=[8, 3, 12, 1]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
False->Fail




number id: 108
label id: SeparateParenGroups:0
puzzle content:
def sat(ls: List[str], combined="() (()) ((() () ())) (() )"):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
run error 3+




number id: 110
label id: SeparateParenGroups:2
puzzle content:
def sat(ls: List[str], combined=" ((((() ())( ( ))())))   "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
run error 3+




number id: 114
label id: Frac:1
puzzle content:
def sat(x: float, v=93.86070917102649):
    return 0 <= x < 1 and (v - x).is_integer()
run error 3+




number id: 115
label id: Frac:2
puzzle content:
def sat(x: float, v=-6.770237138115334):
    return 0 <= x < 1 and (v - x).is_integer()
run error 3+




number id: 188
label id: ParseMusic:0
puzzle content:
def sat(beats: List[int], score="o o o| o| .| .| .| o| o| o o o| .|"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
False->Fail




number id: 192
label id: ParseMusic:4
puzzle content:
def sat(beats: List[int], score=""):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score




number id: 29
label id: Study_30:0
puzzle content:
def sat(li: List[int]):
    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])
False->Fail




number id: 48
label id: BooleanPythagoreanTriples:0
puzzle content:
def sat(colors: List[int], n=100):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
run error 3+




number id: 61
label id: No3Colinear:2
puzzle content:
def sat(coords: List[List[int]], side=1, num_points=1):
    for i1 in range(len(coords)):
        x1, y1 = coords[i1]
        assert 0 <= x1 < side and 0 <= y1 < side
        for i2 in range(i1):
            x2, y2 = coords[i2]
            for i3 in range(i2):
                x3, y3 = coords[i3]
                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0
    return len({(a, b) for a, b in coords}) == len(coords) >= num_points
True->Success




number id: 81
label id: CardGame24:0
puzzle content:
def sat(expr: str, nums=[3, 7, 3, 7]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
run error 3+




number id: 84
label id: CardGame24:3
puzzle content:
def sat(expr: str, nums=[8, 3, 12, 1]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
